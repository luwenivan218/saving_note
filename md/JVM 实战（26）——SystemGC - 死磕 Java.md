> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/1425303268)

> 一、案例背景本章将介绍一个因为程序员同学不懂 JVM 的 GC 机制而导致的系统卡死的案例。首先，这个系统上线之后，平时都还算正常，结果有一次大促活动的时候，系统直接卡死不动了。这个时

一、案例背景
------

本章将介绍一个因为程序员同学不懂 JVM 的 GC 机制而导致的系统卡死的案例。

首先，这个系统上线之后，平时都还算正常，结果有一次大促活动的时候，系统直接卡死不动了。这个时候，我们首先想到的是可不可能是因为频繁 Full GC 导致 Stop the World，正常工作线程无法执行。

### 1.1 存在问题

我们通过 jstat 进行分析，发现 JVM 中各个区域的内存使用都正常，新生代对象增长也不快，老年代也才使用了 10% 左右的空间，永久代也就使用了 20%。

但是，jstat 日志显示，JVM 竟然每秒执行一次 Full GC，每次都耗时几百毫秒。

既然 Java 堆内存都正常，为啥会频繁 Full GC？这是我们立马想到，是不是有开发人员在代码中写了`System.gc()`这种代码，结果通过代码走查，发现确实如此。

二、System.gc 方法
--------------

### 2.1 优化前

开发同学写`System.gc()`这行代码的思路是这样的：某段代码会一下子加载了好多数据，处理完成后这批数据就不用了，占用太多内存，所以就干脆显示调用 GC 方法把它们回收掉吧。

结果在平时没什么问题，因为流量很低。但是大促期间，访问量很高，`System.gc()`方法被频繁调用，因此频繁触发 Full GC，从而导致了上述问题。

### 2.2 优化后

针对这个问题，解决方案就是 **禁止在代码中显式调用`System.gc()`方法** ，GC 完全交由 JVM 自己去处理，可以通过配置 JVM 参数`-XX:+DisableExplicitGC`来强制屏蔽。

三、总结
----

针对本章案例中的问题，我们平时自己写代码时，不要自己去调用`System.gc()`方法随便触发 GC，一方面可以通过在 JVM 参数中加入`-XX:+DisableExplicitGC`显示禁止代码中的 GC 操作，另一方面也要加强对开发人员的 JVM 相关知识的培训。