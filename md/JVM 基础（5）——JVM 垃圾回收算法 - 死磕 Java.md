> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/1735041085)

> 一、简介我们在前两章中，已经讲解了 JVM 垃圾回收的基本流程和对象存活判定的算法，但是，并没有深入垃圾回收内部的细节。本章，我们就深入垃圾回收的内部，看看 JVM 到底是如何进行对象

一、简介
----

我们在前两章中，已经讲解了 JVM 垃圾回收的基本流程和对象存活判定的算法，但是，并没有深入垃圾回收内部的细节。本章，我们就深入垃圾回收的内部，看看 JVM 到底是如何进行对象内存的回收的。

二、复制算法
------

复制算法，主要用于 **新生代** 中对象的回收。其基本思路就是：将新生代内存按划分为大小相等的两块，每次只使用其中的一块，当一块内存用完了， **将存活的对象移动到另外一块上面** ，然后在把已使用过的内存空间一次清理掉。

![](http://image.skjava.com/article/series/jvm/202308102127123531.png)

### 2.1 算法流程

我们以示例代码来看复制算法的执行流程：

```
    public class Kafka {
    
        public static void main(String[] args) throws InterruptedException {
            loadReplicaFromDisk();
        }
    
        private static void loadReplicaFromDisk() {
            ReplicaManager replicaManager = new ReplicaManager();
            replicaManager.load();
        }
    }


```

假设程序执行到 replicaManager.load()，JVM 的内存数据结构如下，其中 “大量垃圾对象无人引用” 表示其它程序产生的垃圾对象，此时新生代中用于分配对象内存的区域也快满了，再次为对象分配内存时就会触发“Minor GC”：

![](http://image.skjava.com/article/series/jvm/202308102127152672.png)

此时，一种最基本的思路就是，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。但是这种方法问题也很明显： **产生大量内存碎片，导致后续需要为大对象分配空间时内不足** 。所以，JVM 很少用这种方法，而是先将存活对象转移到另一块区域：

![](http://image.skjava.com/article/series/jvm/202308102127178313.png)

然后一次性把原来那块内存清空：

![](http://image.skjava.com/article/series/jvm/202308102127223274.png)

上述整个流程，就是所谓的复制算法： **把新生代划分为两块内存区域，只使用其中一块，当这块快满的时候，把存活对象一次性转移到另一块，保证没有内存碎片，然后清空原来那块，依次循环往复** 。

### 2.2 算法优化

上述复制算法的缺点很明显：即 **对内存的使用效率太低** 。比如我们给新生代分配了 1G 内存，那其实只有 512MB 是实际使用的，很浪费内存空间。那么如何来优化呢？

我们回顾下 **新生代中对象的特点：朝生暮死，也就是说新生代的绝大多数对象在经历 1 次 GC 后就会被回收掉，存活率非常低。**

根据这个特点， _HotSpot VM_ 采用了一种做法，把新生代区域划分成了三块： **1 个 Eden 区（80%），2 个 Survivor 区（各占 10%）** ，最开始，对象只在 Eden 进行分配：

![](http://image.skjava.com/article/series/jvm/202308102127245855.png)

如果 Eden 区快满了，此时触发 GC 会将 Eden 区中的存活对象转移到其中一块 Survivor 中，同时清空 Eden：

![](http://image.skjava.com/article/series/jvm/202308102127255726.png)

下一次再分配空间时，依然在 Eden 区分配，然后触发 GC，将 Eden 的存活对象和上一次使用的 Survivor 中的存活对象转移到另一块空白 Survivor 中，然后清空 Eden 和使用过的 Survivor，循环往复。

> 这种内存划分方式的最大好处就是只有 10% 的空间是闲置的，无论是垃圾回收的性能、内存碎片的控制、内存使用率，都非常好。

三、标记整理算法
--------

通过前一节，大家应该已经了解了新生代的垃圾回收算法，本节我们就来看下老年代的垃圾回收算法——标记整理算法。

### 3.1 何时进入老年代

这里有一个问题，新生代的对象什么时候会进入老年代？先给出一个结论，一共有五种情况：

*   新生代对象的年龄超过一定阈值（默认 15）；
*   动态年龄判断
*   大对象直接分配
*   Survivor 区空间不足

#### 年龄阈值

之前我们提到过，新生代中的对象每逃过一轮 GC，年龄都会加 1，到年龄达到 15 时（也可以通过 JVM 参数`-XX:MaxTenuring Threshold`设置），就会被转移到老年代：

![](http://image.skjava.com/article/series/jvm/202308102127275347.png)

![](http://image.skjava.com/article/series/jvm/202308102127280078.png)

#### 动态年龄判断

动态对象年龄判断的规则是： Survivor 区的存活对象年龄从小到大进行累加，当累加到 X 年龄时的总和大于 Survivor 区空间的 50% 时，那么比 X 大的对象都会晋升到老年代。

举个例子，比如当前 Survivor 区的分布如下，累加结果 45% 小于 50%：

![](http://image.skjava.com/article/series/jvm/202308102127287349.png)

此时新生代 GC 后，有 6% 的对象进入 Survivor 区，则 Survivor 区分布如下图：

![](http://image.skjava.com/article/series/jvm/2023081021272933710.png)

这时从 1 岁加到 4 岁的对象总和 51% 大于 50%，但此时没有大于四岁的对象，即没有对象晋升 。此时再经过一次新生代 GC 后，又有 40% 的对象进入 Survivor 区，Survivor 区分布如下图：

![](http://image.skjava.com/article/series/jvm/2023081021272995211.png)  
Survivor 区的对象年龄从小到大进行累加，当累加到 3 年龄时的总和大于 50%，那么比 3 大的都会晋升到老年代，即 4 岁的 20%、5 岁的 20% 晋升到老年代。

> 可以使用 - XX:TargetSurvivorRatio 来设置 Survivor 区空间的百分比，默认值是 50

#### 大对象

对于一些大对象，JVM 会直接将其分配到老年代。通过参数 - XX:PretenureSizeThrehold，可以设置阈值，单位为字节。

JVM 之所以要这么做，是为了避免新生代中出现屡次逃过 GC 的大对象，大对象在新生代的 Eden 和 Survivor 区的来回复制开销比较大。

#### Survivor 区空间不足

最后一种情况就是，Minor GC 之后发现存活对象太多，没法放入另一块 Survivor 区域中，比如下面这种情况：

![](http://image.skjava.com/article/series/jvm/2023081021273062412.png)

这时候就必须把这些对象全部迁移到老年代去：

![](http://image.skjava.com/article/series/jvm/2023081021273112413.png)

### 3.2 空间分配担保

前面讨论了新生代的存活对象何时会转移到老年代，那么问题又来了，如果老年代区域的内存空间不足了怎么办？这里就涉及了 **空间分配担保机制** 。

所谓空间分配担保，指在执行任何一次 Minor GC 之前，JVM 会检查 **老年代的最大连续可用空间** 是否大于 **新生代所有对象的总大小** ：

如果大于，说明这次 Minor GC 肯定是安全的，因为老年代可以容纳新生代中的所有对象；

如果小于，则 JVM 会查看`-XX:HandlePromotionFailure`参数值，这个参数值表示是否允许担保失败：

*   如果允许（`HandlePromotionFailure==true`），则看下 **老年代的最大连续可用空间** 是否大于 **历次 Minor GC 后进入老年代的对象平均大小** 。如果大于，就进行 minior GC，如果这次 Minior GC 失败了，就会进行 FULL GC（所谓 FULL GC，就是既对老年代进行垃圾回收，也对新生代进行垃圾回收）；如果小于，先进行 FULL GC，再 Minor GC。
*   如果不允许（`HandlePromotionFailure==false`），则直接触发 FULL GC，然后再进行一次 Minor GC。

如果经过上面的操作，老年代可用空间最后发现还是不够，就会导致所谓的 OOM 内存溢出了。

> 总之，空间分配担保机制的核心目的就是 **避免频繁 FULL GC，能先预判就先预判** ，实在不行才 FULL GC，因为 FULL GC 的开销非常大，既要对老年代进行回收，也要对新生代进行回收。

### 3.3 算法流程

了解了新生代对象何时进入老年代，以及 FULL GC 的触发时机，我们就可以来看下老年代的 **标记整理算法** 的流程了。标记整理算法，其实就是先标记存活对象，然后将存活对象都向内存端边界移动，然后清理掉端边界以外的内存，这样就可以避免出现大量内存碎片。

我们通过示例来看下，假设 JVM 当前的内存状态如下，老年代中散落着各种存活对象：

![](http://image.skjava.com/article/series/jvm/2023081021273197514.png)

接着，会将存活对象都往内存的一边移动，让它们尽量紧凑，然后一次性把垃圾对象清理掉：

![](http://image.skjava.com/article/series/jvm/2023081021273346215.png)

四、线上示例
------

通过前两节的讲解，相信读者已经对新生代的复制算法、老年代的标记整理算法有所了解，本节我们将通过一个生产系统的 GC 案例，让大家更加透彻的理解 JVM 中如果进行对象分配和老年代转移，以及 Minor GC 和 Full GC 的全过程。

### 4.1 背景

假设现在生产环境有一套 “数据计算系统”，不停地从 MySQL 等各类数据源提取数据到内存中进行计算，系统是分布式的。每个节点（机器）每分钟执行 100 次操作（提取数据并计算，每次操作耗时 10s），每次操作 1 万条数据，每条数据大小为 1KB 左右，那么每次数据的总大小就是 10MB：

![](http://image.skjava.com/article/series/jvm/2023081021273431616.png)

> 每台机器的配置是 4 核 8G，JVM 分配 4G 内存，其中新生代 1.5G，老年代 1.5G。

整个系统的初始背景大致就是上面这样，下面来分析可能存在的各种问题。

### 4.2 频繁 Full GC

我们先来看下新生代的空间什么时候会被占满，按照 8：1：1 来分配 Eden 和 Survivor 区，如下图：

![](http://image.skjava.com/article/series/jvm/2023081021273485917.png)

每执行一次操作，Eden 区就会填充 10MB 数据，一分钟执行 100 次操作就是 1000MB，所以 **Eden 区基本上 1 分钟左右就会被占满** 。再执行操作时，就会进行 Minor 以回收一部分的垃圾对象：

首先，检查老年代的连续可用内存空间是否足够（即大于新生代中的所有存活对象大小），如下图，老年代目前是空的，1.5G 的可用内存空间可以容纳 Eden 区中的 1.2G 对象，所以会直接进行 Minor GC：

![](http://image.skjava.com/article/series/jvm/2023081021273555618.png)

那么， **此时 Eden 区中有多少对象还是存活的呢？** 之前说了每次操作耗时 10s，那么在 1 分钟内的最后 10s 时，前面 0-50s 的任务已经执行完了，1 分钟操作 100 个任务，所以大约有 1/6 的任务还没有执行完毕，即大约还有 20 个任务在计算中（大约 200MB 对象存活）：

> 其实线上一般是通过 GC 日志去分析存活对象的大小的，GC 日志中清楚的记录了每次 Minor GC 进入到老年代的对象大小（后面我们会详细讲解如何看懂 GC 日志），根据我们的线上日志分析，大约也还有 200MB 对象是存活的。

注意，每一块 Survivor 区的大小只有 100MB，所以是无法容纳 200MB 的存活对象的，所以会通过空间担保机制，转移到老年代中，并清空 Eden 区，此时 JVM 内存空间结构如下：

![](http://image.skjava.com/article/series/jvm/2023081021273707819.png)

由于每分钟老年代都被填充 200MB 存活对象，所以到第 3 分钟结束时，老年代已经有 400MB 空间被占满，且 Eden 区也被占满，此时如果要进行 Minor GC，会怎么样呢？

![](http://image.skjava.com/article/series/jvm/2023081021273781420.png)

首先，依然检查老年代的连续可用内存空间是否足够（即大于新生代中的所有存活对象大小），此时发现空间是不够的，老年代只有 1.1GB 可用，而新生代的所有对象大小有 1.2GB。

此时，就会判断是否开启了空间担保机制——即判断`HandlePromotionFailure`是否为 true，如果开启了（一般生产环境都会开启），就会看下历代晋升到老年代的对象大小是否小于老年代可用空间，根据之前的计算，历代晋升到老年代的对象大小约为 200MB，小于 1.1GB，所以 JVM 就会放心的进行一次 Minor GC，此时又有 200MB 对象进入到老年代。

重复上述过程，大约经过 8 分钟，经历 7 次 Minor GC 后，JVM 内存空间结构如下，此时老年代剩余可用空间大约 100MB，Eden 区已被占满：

![](http://image.skjava.com/article/series/jvm/2023081021273850921.png)

此时又会进行 Minor GC 前的检查，但是老年代的可用空间已经比历代晋升到老年代的对象空间小了，所以会 **直接触发一次 Full GC** ，将老年代中的垃圾对象回收（假设此时老年代中的对象全部都可回收）：

![](http://image.skjava.com/article/series/jvm/2023081021273938622.png)

然后紧接着再进行一次 Minor GC，将 Eden 区中的 200MB 存活对象转移到老年代：

![](http://image.skjava.com/article/series/jvm/2023081021274025423.png)

> 按照上述这个模型， **基本上 8 分钟左右就会触发一次 Full GC** ，这个频率对于生产环境是不可接受的，因为 Full GC 会严重影响系统性能，这个后面章节我们会详细讲解。

### 4.3 优化

那么该如何进行优化呢？最基本的思路就是 **增加 Survivor 的内存大小** ，因为正是 Survivor 区不能容纳存活对象（200MB）导致必须晋升到老年代。所以重新分配新生代大小为 2G，老年代为 1G，同时改变 Eden 和 Survivor 的空间比例，这样 Survivor 区就能容纳每次 Minor GC 后的存活对象，如下图：

![](http://image.skjava.com/article/series/jvm/2023081021274156724.png)

比如经过一段时间，JVM 内存结果如下，Eden 区被占满，Survivor1 区有 200MB 上一轮 Minor GC 后的存活对象：

![](http://image.skjava.com/article/series/jvm/2023081021274328825.png)

然后此时进行 Minor GC，会先清理到 S1 区中的所有对象，然后将 Eden 区中的存活对象（200MB）转移到 S2 区：

![](http://image.skjava.com/article/series/jvm/2023081021274424626.png)

这样，基本上就很少会有对象进入到老年代，Full GC 的频率能降低到几小时一次。

五、总结
----

最后来总结下本章的内容，本章主要介绍了新生代的复制算法和老年代的标记整理算法的流程，重点需要掌握的是以下几点：

1.  新生代对象何时会进入老年代？
2.  何时会触发新生代的 Minor GC？
3.  何时会触发 FULL GC？
4.  空间分配担保机制的作用是什么？

同时，本章也给出了一个线上示例，帮助读者更好的理解 JVM 分代垃圾回收的整个流程。下一章开始，我们将详细介绍各种垃圾回收器，看看它们内部是如何运用 GC 算法进行垃圾回收的。