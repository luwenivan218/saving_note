> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7316202730955522074)

JDK21 在用，目前最新的垃圾回收器——ZGC 垃圾回收器原理简析
==================================

欢迎关注，​分享更多原创技术内容～

微信公众号：ByteRaccoon、知乎 \ 稀土掘金都叫：浣熊 say

微信公众号海量 Java、数字孪生、工业互联网电子书免费送～

ZGC 简述
------

### 什么是 ZGC？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7886a90c7e45fa97f32870bc9794fd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1524&h=742&s=310790&e=png&b=fefefe)

ZGC（Z Garbage Collector）是 Java 虚拟机中的一种垃圾回收器，属于低延迟垃圾回收器，它的设计目标就是在保持较低的停顿时间的同时，能够处理非常大的堆内存。

目前已经可以将停顿时间降低到 10ms 左右。ZGC 是从 JDK 11 版本开始引入的，并在后续版本中进行了改进和优化。

如上图所示是 ZGC 垃圾回收器和 Parallel 和 G1 等垃圾回收器相比较起来的 GC Pause，可以发现其 GC 停顿已经降低到的很客观的程度，并且这个 GC 停顿的时间还是可以自主进行配置的。

ZGC 的实现没有采用分代收集机制，但是和 [G1 垃圾回收器](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484154&idx=1&sn=69ce4608eea3c24acf4d5d675129c240&chksm=c25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6#rd")类似，采用了分区策略，下面是 ZGC 的一些特性和设计原则：

1.  **低停顿时间：** ZGC 的主要设计目标之一是实现低停顿时间，停顿时间（STW）不会超过 10ms，这个停顿时间还可以根据实际的项目需求进行配置；
2.  **处理大内存堆：** ZGC 被设计为能够处理非常大的堆内存，支持 8MB～4TB 级别的堆内存，未来会支持 16TB；
3.  **并发收集：** ZGC 在执行垃圾回收时，会与应用程序线程并发工作，减少了停顿时间，这意味着即使在进行垃圾回收时，应用程序也能够继续执行，降低了对应用性能的影响；
4.  **可预测的停顿：** ZGC 追求更加可预测的停顿时间，避免因垃圾回收而引起的不确定性。这对于需要保证应用程序的响应时间和稳定性的场景非常重要；
5.  **处理不同的内存分配模式：** ZGC 适应了现代应用程序中常见的内存分配模式，包括大对象、小对象、短期存活对象等，以提高垃圾回收的效率；
6.  **实时可达性分析：** ZGC 使用了一种实时的可达性分析算法，以更快地找到不再使用的对象，减少垃圾回收的时间。

总体而言，ZGC 是为了满足对低延迟和大内存的需求而设计的一种垃圾回收器，适用于对应用程序响应时间要求较高的场景。

### ZGC 启用和相关参数

在 Java 应用程序中启用 ZGC，可以使用以下命令行参数：

```
java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -jar YourApplication.jar


```

这个命令包括两个关键的 VM 选项：

*   `-XX:+UnlockExperimentalVMOptions`：解锁实验性的 VM 选项，允许使用实验性的垃圾回收器。
*   `-XX:+UseZGC`：启用 Z Garbage Collector。

ZGC 是作为实验性特性引入的，具体取决于您使用的 JVM 版本，需要确保你的 Java 版本支持 ZGC，另外一些 ZGC 的常见重要参数如下：

<table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>-XX:ZCollectionInterval</td><td>固定时间间隔进行 GC</td><td>0</td></tr><tr><td>-XX:ZAllocationSpikeTolerance</td><td>内存分配速率预估的一个修正因子</td><td>2</td></tr><tr><td>-XX:ZProactive</td><td>是否启用主动回收策略</td><td>true</td></tr><tr><td>-XX:ZUncommit</td><td>将不再使用的内存还给 OS（JDK13 及以上版本）</td><td>-</td></tr><tr><td>-XX:+UseLargePages -XX:ZPath</td><td>使用大内存页，配置 Huge Pages 可以提高性能</td><td>-</td></tr><tr><td>-XX:UseNUMA</td><td>启用 NUMA 支持</td><td>true</td></tr><tr><td>-XX:ZFragmentationLimit</td><td>根据当前 region 已大于 ZFragmentationLimit，则回收</td><td>25</td></tr><tr><td>-XX:ZStatisticsInterval</td><td>设置打印 ZStat 统计数据的间隔（CPU、内存等日志）</td><td>-</td></tr></tbody></table>

ZGC（Z Garbage Collector）原理
--------------------------

### ZGC 内存布局

ZGC（Z Garbage Collector）的内存布局与 G1（Garbage-First）在内存布局上有些相似，都采用了基于 Region 的堆内存布局。ZGC 在内存布局方面引入了一些动态性的概念，Region 的大小不是固定不变的，也不会区分新生代、老年代区域（实际在 JDK21 中又引入了新老年代分区的概念，后续我会继续跟踪出一版新的原理），使得它更加灵活和适应不同场景。

ZGC 的内存布局主要涉及到动态创建、动态销毁以及动态的区域容量大小，以下是 ZGC 内存布局的一些关键特点：

1.  **动态创建：** ZGC 的 Region 可以根据需要动态创建，系统可以根据应用程序的实际内存需求，动态生成新的内存区域，以适应不同的工作负载。
2.  **动态销毁：** 类似地，ZGC 的 Region 也可以根据垃圾回收的情况动态销毁，当某个区域内的对象被回收后，该区域可以被标记为可用，随后可以被重新分配或销毁，以便更好地管理内存。
3.  **动态的区域容量大小：** ZGC 引入了不同大小的 Region，包括 Small Region（2MB）、Medium Region（32MB）和 Large Region（可变大小），使得 ZGC 在内存分配时能够更好地适应不同大小的对象，提高内存利用率。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57cbab3d3e194117816177ed5896196c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1296&h=882&s=99591&e=png&b=ffffff)

如上图所示，ZGC 的 Region 分类包括：

*   **Small Region（小区域）：** 大小为 2MB，用于存放小于 256KB 的小对象。这有助于提高小对象的分配和回收效率。
    
*   **Medium Region（中等区域）：** 大小为 32MB，用于存放大于等于 256KB 但小于 4MB 的对象。中等区域的引入有助于处理中等大小的对象。
    
*   **Large Region（大区域）：** 大区域的大小是可变的，最小为 4MB。每个大区域只用于存放一个大对象，且不会被重新分配，这有助于处理大对象，减少内存碎片化。
    

这种动态的内存布局设计使得 ZGC 能够更好地适应不同的工作负载和对象分布模式。它能够在提供低延迟的同时，更加高效地管理内存空间，降低内存碎片化的程度。

### ZGC 的垃圾标记算法——染色指针

#### 什么是染色指针？

在 ZGC 出现之前，GC 信息被保存在对象头的 Mark Word 当中，如 64 位的 JVM，对象头的 Mark Word 中保存的信息如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fcf9ae452464590a17a7480eec09a85~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=803&h=351&s=15441&e=png&b=ffffff)

64 位的 MarkWord 中保存了 GC 和对象相关的信息，包括：对象的哈希码、分代年龄、锁记录等。由于这些信息存在于对象头的 MarkWord 中，而对象实体一般存储在堆内存中，[虚拟机栈](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484233%26idx%3D1%26sn%3D2a2f9b4370d4d0557d3bb17a4e838a50%26chksm%3Dc25f8f07f5280611a99843bb111b36cbf723856a9e502cc32927852793a5c0611ef127131acc%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484233&idx=1&sn=2a2f9b4370d4d0557d3bb17a4e838a50&chksm=c25f8f07f5280611a99843bb111b36cbf723856a9e502cc32927852793a5c0611ef127131acc#rd")帧中的局部变量表中存储的则是堆中对象的引用（指针）。因此，当访问对象的时候获取这些信息是很方便的，但是当我们在希望不直接访问对象，仅仅通过对象的指针就得到这些信息的话，这种实现方式就做不到。

但是，在追踪式垃圾回收算法的标记阶段，例如：[三色标记算法](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484154&idx=1&sn=69ce4608eea3c24acf4d5d675129c240&chksm=c25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6#rd")，则可能存在只需要处理指针而无需加载指针所引用的对象的情况。例如在[三色标记算法](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484154&idx=1&sn=69ce4608eea3c24acf4d5d675129c240&chksm=c25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6#rd")当中，JVM 需要给对象打上黑、白、灰色的标记，但是这些标记只与对象的引用有关，与对象本身的其它属性无关。这样的场景下理论上我们只需要为对象的指针打上标记即可，无需在堆内存中为实际的对象打上标记。

然而，当前 HotSpot 虚拟机对标记方案的实现各不相同，采用了包括：对象头标记、BitMap 映射和染色指针等不同方法，具体如下：

*   Serial、PS、ParNew、CMS：这些垃圾回收器都是直接将标记信息打在对象头上的，因此写入和读取标记需要时机访问堆中对象。
*   G1、Shenandoah：将标记信息记录在与对象独立的数据结构上，通常是一种 BitMap 的结构，一般相当于堆内存的 1/64 大小。
*   ZGC：采用染色指针的方式，直接将标记信息存储在引用对象的指针上，从而实现遍历 “引用图” 来标记 “引用” 的效果，而不是遍历对象图来标记对象。

总之，理解染色指针首先要理解[三色标记算法](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484154&idx=1&sn=69ce4608eea3c24acf4d5d675129c240&chksm=c25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6#rd")这个垃圾标记算法，[三色标记算法](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd "https://mp.weixin.qq.com/s?__biz=MzkzMjI0MDY3Mw==&mid=2247484154&idx=1&sn=69ce4608eea3c24acf4d5d675129c240&chksm=c25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6#rd")会为对象打上白、灰、黑三种颜色。在 ZGC 之前的垃圾回收器中，颜色标记都是被打在对象头的 MarkWord 当中的，这样判断是否是垃圾需要去实际访问堆中对象。

而染色指针则可以将颜色标记直接记录在指针上，这样就省去了访问实际对象的过程。这样一来，垃圾标记阶段遍历的不再是对象图来标记垃圾，而是通过遍历 “引用图” 来标记垃圾，引用的对象便是堆中的对象。

#### 染色指针的实现原理

##### 染色指针的结构

染色指针简单来说就是一种将额外少量的垃圾标记信息（颜色信息）存储在对象指针上的技术，在 64 位操作系统中，对象指针的长度也是 64 位，染色指针的结构图如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97036eb1ebc44da5911fd0459329a5a2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=903&h=457&s=27185&e=png&b=ffffff) 在染色指针中，高 18 位都是 0 暂未使用，剩余的 46 位实际上是能支持 64TB 的内存的，但是目前来说计算机内存空间还没这么大。于是剩余的 46 位中，高 4 位用来保存了 4 个标志位，低 42 位置才是用来保存对象的指针，所以 ZGC 最大可以管理的内存不超过 4TB。染色指针中 4 个标志位的具体作用如下：

1.  **Marked 0 和 Marked 1 标志位：**
    *   **作用：** 用于表示对象的三色标记状态，通常用于垃圾收集算法中的标记阶段。
    *   **意义：** 提供了直观的对象垃圾收集状态，通过这两个标志位，JVM 可以轻松地追踪对象的标记状态，即未标记、已标记（Marked 0 或 Marked 1）等。
2.  **Remapped 标志位：**
    *   **作用：** 表示对象是否已经进入了重分配集，即是否需要在内存重分配时进行特殊处理。
    *   **意义：** 对于 ZGC 垃圾收集算法，该标志位的存在能够提供更高效的内存重分配，避免不必要的复制或移动操作，从而提高垃圾收集的性能。
3.  **Finalizable 标志位：**
    *   **作用：** 标识对象是否需要通过 finalize 方法进行访问，即是否需要执行清理和释放资源的操作。
    *   **意义：** 允许 JVM 更灵活地处理对象的生命周期，根据 Finalizable 标志位的状态来判断是否触发 finalize 方法，这在一些需要资源释放的情景下尤为重要。

通过这四个标志位，JVM 可以直接从对象的指针上获取关键的状态信息，而无需访问对象本身的其他属性，这种直接的标志位设计有助于提高垃圾收集的效率和性能。

##### 虚拟内存映射

但是，上面的染色指针的实现方案中存在着一个问题——如何映射到真实的内存物理地址。因为 JVM 作为一个普通的进程，这样随意的定义指针中的某几位操作系统是不认可得。实际上 Java 程序最终都会被转换成机器指令交给具体的平台去执行，CPU 可不会认可你 Java 自己定义的指针结构，只会把整个指针都看作普通的内存地址去映射到物理内存地址。一般的 x86-64 平台也不支持重新定义机器指令，因此，ZGC 就只有采用了虚拟内存映射这个技术来解决这个问题。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8597386feb14557917e952b374aa1e3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=956&h=612&s=50107&e=png&b=ffffff)

在 x86 平台上，CPU 使用分页管理机制将**线性地址空间**和**物理地址空间**划分为大小相同的块，即 "页"(Page)。通过建立映射表，分页管理机制完成线性地址到物理地址的转换。这保证了程序对虚拟内存的访问可以映射到相应的物理内存地址上。可以简单理解为使用 mmap 将不同的虚拟内存地址映射到同一个物理内存地址上。

如上图，ZGC 采用虚拟内存映射技术，将同一块物理内存映射为 Marked 0、Marked 1 和 Remapped 这三个虚拟内存。每个对象在堆上申请虚拟地址时，ZGC 为该对象在这三个视图空间分别分配虚拟地址，这三个虚拟地址映射到同一个物理地址。

染色指针中，Marked 0、Marked 1 和 Remapped 作为 ZGC 的三个视图空间，在同一时间点内只能有一个是有效的。通过切换这三个视图空间，ZGC 实现了并发的垃圾回收，对象的标记信息和状态可以在不同的视图之间切换，从而实现垃圾回收的并发性。在后续的 ZGC 回收流程中我们将详细介绍这三个视图空间的切换流程。

#### 指自愈指针（Self-Healing Pointers）

自愈指针（Self-Healing Pointers）是指一种用于在并发垃圾回收中进行引用修复的技术。这种技术的目的是在对象移动时，通过修改指针本身而不是对象的引用关系，来维护正确的引用关系，从而避免了对引用对象的访问和修改。

在垃圾回收的过程中，如果对象发生移动，原本指向该对象的引用关系就会失效。传统的垃圾回收器需要遍历对象图，修复所有指向移动对象的引用，这会带来一定的性能开销。而自愈指针技术通过直接修改指针来维护引用关系，减少了对对象的访问和修改，提高了并发性能。

在自愈指针技术中，指针的高位（通常是一些特定的位或字节）被用来存储额外的信息，例如对象的新地址、标记信息等。当对象移动时，只需要修改指针的高位信息，而不需要访问对象本身，从而实现引用的自愈。

这种技术通常应用于并发垃圾回收算法中，其中对象的移动是允许的，并发标记和并发移动阶段需要通过自愈指针来保证引用的正确性。ZGC（Z Garbage Collector）就是一种使用了自愈指针技术的垃圾回收器，它通过虚拟内存映射和染色指针来实现并发垃圾回收，减小了对引用修复的停顿时间。

#### 染色指针的优势

1.  **即时回收空间：** 当某个 Region 中的存活对象被成功移走后，该 Region 就能够立即释放和重用，而无需等待整个堆中所有指向该 Region 的引用都被修正。这意味着，理论上只要还有一个空闲的 Region，ZGC 就能完成垃圾收集。相比之下，Shenandoah 需要等到更新阶段结束才能释放回收集中的 Region，特别是在 Region 内的对象都存活时，需要 1:1 的空间才能完成收集。
2.  **减少内存屏障使用：** 染色指针可以显著减少在垃圾收集过程中内存屏障的使用数量。ZGC 仅使用了读屏障，而不需要其他类型的内存屏障。这有助于提高垃圾收集的效率和性能。
3.  **强大的扩展性：** 染色指针具备强大的扩展性，可以作为一种可扩展的存储结构，用于记录与对象标记、重定位过程相关的更多数据。这为将来进一步提高性能提供了可能性，使 ZGC 能够灵活适应不同的场景和需求。

ZGC 的垃圾回收原理
-----------

### ZGC 触发时机

ZGC 的触发时机主要取决于堆的占用情况以及对象分配的速率。ZGC 是一种响应式的垃圾回收器，会在满足一定触发条件时启动垃圾回收。以下是 ZGC 触发的主要时机：

1.  ** 堆空间占用达到阈值：** 当堆空间的占用达到一定的阈值时，ZGC 可能会被触发。这个阈值可以通过启动 JVM 时的参数进行配置。一旦堆空间占用超过了指定的阈值，ZGC 就有可能被启动。
2.  ** 对象分配速率：**ZGC 会监测对象的分配速率。如果对象分配速率较高，导致堆空间迅速被占满，ZGC 可能会被启动以回收内存。这种情况下，ZGC 可以防止堆空间迅速耗尽，保持应用程序的正常运行。
3.  ** 空闲时间较长：**ZGC 具有适应性的特性，会根据应用程序的执行情况和空闲时间来判断是否进行垃圾回收。当应用程序处于空闲状态时，ZGC 可能会选择启动垃圾回收，以尽量减小对应用程序的干扰。
4.  ** 手动触发：** 开发人员也可以通过 Java Management Extensions（JMX）或其他工具手动触发 ZGC 的垃圾回收。这在一些特殊场景下可能会被使用，例如在某个业务逻辑执行完成后手动触发垃圾回收以及时释放内存。

ZGC 是为了保持低停顿时间而设计的，因此它可能根据应用程序的需求动态调整触发时机，以最大程度地减小停顿时间。在大多数情况下，ZGC 的触发时机是由垃圾收集器自动管理的。

### ZGC 垃圾回收整体流程

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ed8fc77a8249eeb0c2d9851f725583~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1812&h=940&s=146414&e=png&b=fefbfb)

ZGC（Garbage Collector）是一种在 JVM 中实现的低停顿时间垃圾回收器。其垃圾回收流程可以概括为以下几个关键阶段：

1.  ** 初始标记阶段（Initial Mark）：** 与 G1 垃圾回收器一样，初始标记阶段是一个短暂的 STW 阶段，目的是标记出根对象直接引用的对象，标记的过程是并发执行的，所以这个阶段的停顿时间很短。
    
2.  ** 并发标记阶段（Concurrent Mark）：** 在这个阶段，ZGC 并发地标记出所有可达的对象，包括从根对象出发的引用链上的对象，这个过程是与应用程序的执行同时进行的，因此对停顿时间的影响很小。
    
3.  ** 再标记阶段（Remark）：** 如果在并发标记阶段有新的对象被创建或有对象被回收，ZGC 可能需要进行一次短暂的 STW 再标记。这个阶段的停顿时间一般不超过 1 毫秒。在这个阶段，ZGC 会修正并发标记阶段可能由于并发引起的标记不一致。
    
4.  ** 并发转移准备（Concurrent Prepare for Relocate）：** 在这个阶段 ZGC 进行整堆扫描，确定收集哪些 Region，并将这些 Region 组成重分配集（Relocation Set）。与 G1 收集器不同，ZGC 的重分配集扫描所有的 Region，而不是计算最有价值回收的 Region，由于染色指针的存在，扫描过程会很快。这个过程并不是为了计算最优的回收集，而是为了确定存活对象将被复制到其他 Region。此阶段还涉及到 JDK12 支持的类卸载和弱引用的处理。
    
5.  ** 初始转移阶段（Initial Relocation）：** 这是 ZGC 垃圾回收的核心阶段之一，ZGC 并发地将重分配集中的存活对象复制到新的 Region。为了记录从旧对象到新对象的转移关系，ZGC 需要为重分配集中的每个 Region 维护一个转发表（Forward Table）。
    
    ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC 将这种行为称为指针的 “自愈”（Self-Healing）能力
    
    ZGC 的染色指针因为 “自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，而 Shenandoah 的 Brooks 转发指针是每次都会变慢。 一旦重分配集中某个 Region 的存活对象都复制完毕后，这个 Region 就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。
    
6.  **并发转移阶段（Concurrent Relocation）：**并发转移阶段的工作就是修正堆中指向重分配集中旧对象的所有引用，也可以直接认为就是真正进行对象引用修复的一个步骤，从这一点来看 shenandoah 的并发引用更新阶段是一样的。但是 ZGC 并不需要马上完成这个操作（因为有指针自愈的特性），ZGC 把并发重映射阶段要做的工作巧妙的合并到**下一次垃圾收集循环**中的并发标记阶段中去完成，这样做的好处是节省遍历对象图的开销。一旦所有指针修复，新旧对象的引用关系**转发表**就可以释放了。
    

以上阶段中，除了初始标记、再标记阶段和初始转移阶段有短暂的 STW 时间外，其他阶段都是并发执行的，尽量减小了垃圾回收对应用程序的干扰，从而实现低停顿时间。这种并发执行的特性使得 ZGC 适用于大内存堆的 Java 应用，尤其是需要低延迟的场景。

#### ZGC 垃圾回收并发处理的视图切换

单纯从 ZGC 的整体流程上看，似乎很难看出染色指针在 ZGC 的垃圾回收流程的作用，实际上 ZGC 在垃圾标记的过程中会改变染色指针的颜色位，将内存区域切换成 ReMapped、M0 或者 M1 状态，方便快速判断对象的存活状态。同时，由于扫描指针比较清亮，ZGC 每次执行都是进行全堆扫描的。具体视图切换的地方如下图所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b73a6a32b67c4e43888b948646f16f95~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=778&s=321883&e=png&b=fefefe)

如上图所示，ZGC 的垃圾回收周期中涉及的地址视图切换过程可以分为以下几个阶段：

1.  ** 初始化阶段：** 初始时，整个内存空间的地址视图被设置为 Remapped，意思是该内存的 Region 处于重置集当中，无需进行转移或者垃圾清理。程序正常运行和分配对象，并在一定条件下触发垃圾回收。
2.  ** 并发标记阶段：** 第一次进入标记阶段时，视图为 M0。如果对象被 GC 标记线程或应用线程访问过，将对象的地址视图从 Remapped 调整为 M0。标记阶段结束后，对象的地址要么是 M0 视图，说明对象是活跃的；要么是 Remapped 视图，说明对象是不活跃的。
3.  ** 并发转移阶段：** 标记结束后，进入转移阶段，此时地址视图再次被设置为 Remapped。如果对象被 GC 转移线程或应用线程访问过，将对象的地址视图从 M0 调整为 Remapped。
4.  ** 第二次并发标记阶段：** 在第二次进入并发标记阶段时，地址视图调整为 M1，而非 M0。这样设计是为了区别前一次标记和当前标记，确保在不同的标记阶段使用不同的地址视图。

在并发标记阶段，采用**着色指针**和**读屏障技术**。将对象设置为已标记时，只需设置指针地址的第 42~45 位，不需要进行一次内存访问，且速度比访问内存更快。这种技术使得传统的将对象存活信息放在对象头中的方式变得不再必要，从而提高了标记的效率。

通过这样的设计，ZGC 实现了并发的垃圾回收，减少了停顿时间，并通过多次标记阶段和地址视图的切换，有效地管理对象的存活状态。

### ZGC 的优缺点

<table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>1. 低停顿</td><td>ZGC 以低停顿为首要目标，几乎所有垃圾回收过程都是并发的，只有短暂的 STW。</td></tr><tr><td>2. 高吞吐量</td><td>ZGC 在吞吐量方面取得了显著进展，超越了 G1，接近 Parallel Scavenge。</td></tr><tr><td>3. 内存小</td><td>没有写屏障和卡表等额外的数据结构，收集过程中额外耗费的内存较小。</td></tr><tr><td>4. 局部内存分配</td><td>在多核处理器的某些架构下，优先在当前线程所处的处理器的本地内存上分配对象。</td></tr><tr><td>5. 并发停顿</td><td>并发停顿非常短暂，大部分过程都是与应用线程并发执行。</td></tr><tr><td>6. 无分代</td><td>没有引入分代的概念，简化了内存管理的复杂性。</td></tr><tr><td>7. 无内存碎片</td><td>采用并发的标记 - 整理算法，没有内存碎片问题。</td></tr></tbody></table>

<table><thead><tr><th>缺点</th><th>描述</th></tr></thead><tbody><tr><td>1. 浮动垃圾</td><td>承受的对象分配速率不会太高，产生浮动垃圾，难以及时回收。</td></tr><tr><td>2. 执行时间较长</td><td>停顿时间短，但整个垃圾回收过程的执行时间可能较长。</td></tr><tr><td>3. 无分代概念</td><td>没有分代概念，可能导致朝生夕死的对象无法及时回收。</td></tr><tr><td>4. 平台限制</td><td>目前仅在 Linux/x64 上可用，可能限制了在其他平台的应用。</td></tr></tbody></table>

总结
--

ZGC 和 G1 垃圾回收器一样采用了 Region 的机制来完成对垃圾的回收和标记，不同的是 ZGC 将 Region 分为了 small、medium 和 large，并且单个 region 可以存放多个对象，但是大对象只会存放在单个 large 区域当中。

对于垃圾的发现算法，ZGC 采用了和以前的垃圾回收器都不同的染色指针算法，可以根据对象指针就能够快速的判断对象的存活状态，而无需去对象头中读取相关的信息，垃圾标记效率显著提升。

最终，垃圾的标记阶段和 CMS、G1 垃圾回收器有些类似，都有初始标记、并发标记、最终标记来尽可能多的标记好堆中的垃圾。之后，ZGC 独有的并发转移准备、初始转移和并发转移会维护一个 Region 之间的转发表，来完成垃圾的高效回收。

本文只是对 ZGC 垃圾回收器概念上和基本原理的浅析，关注我，后续带大家从 JDK 21 源码理解 ZGC 的核心原理。（PS：我觉得网上的 bolg 多多少少有些问题，后续打算开个专栏从 HotSpot 源码解析来真正的出一份正确的 JVM 核心原理的专栏，这里挖个坑～）