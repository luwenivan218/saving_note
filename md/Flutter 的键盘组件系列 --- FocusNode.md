> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7127297886743691272)

携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第 2 天，[点击查看活动详情](https://juejin.cn/post/7123120819437322247 "https://juejin.cn/post/7123120819437322247")

基本概念
====

以下是面向平台的 开发 Flutter 应用程序的开发人员应该了解使用物理键盘的基本概念。

*   **Focus tree**— 焦点节点树，通常稀疏地镜像小部件树，代表所有可以接收焦点的小部件。
*   **Focus node**— 焦点树中的单个节点。该节点可以接收焦点，当它是焦点链的一部分时，称为 “有焦点”。它仅在具有焦点时才参与处理关键事件。
*   **Primary focus**— 距具有焦点的焦点树根最远的焦点节点。这是关键事件开始传播到主要焦点节点及其祖先的焦点节点。
*   **Focus chain**——焦点节点的有序列表，从主要焦点节点开始，沿着焦点树的分支到焦点树的根。
*   **Focus scope**——一个特殊的焦点节点，其工作是包含一组其他焦点节点，并且只允许这些节点接收焦点。它包含有关哪些节点先前集中在其子树中的信息。
*   **Focus traversal**——以可预测的顺序从一个可聚焦节点移动到另一个的过程。**当用户按下 Tab** 键移动到下一个可聚焦控件或字段时，这通常出现在应用程序中。

FocusNode 和 FocusScopeNode
==========================

这两个对象就像渲染对象一样的拥有比较长生命周期，他俩比任何其他小部件的生命周期都要长，因此在不同小部件的构建方法之间也是持久的。它们共同构成了焦点树数据结构。

创建 FocusNode 对象的最佳实践
====================

由于这些是最佳实践，因此至少对于这一部分，我们必须只听官方文档。它说以下。  
不要`FocusNode`为每个构建分配一个新的。这可能会导致内存泄漏，并且在节点具有焦点的情况下重建小部件时偶尔会导致焦点丢失。

*   在有状态的小部件中创建`FocusNode`和`FocusScopeNode`对象。`FocusNode`并且`FocusScopeNode`需要在您完成使用它们时进行处理，因此它们应该只在有状态小部件的状态对象内创建，您可以在其中覆盖`dispose`以处理它们。
    
*   不要`FocusNode`对多个小部件使用相同的。如果这样做，小部件将争夺管理节点的属性，并且您可能不会得到您期望的结果。
    
*   请设置`debugLabel`焦点节点小部件以帮助诊断焦点问题。
    
*   不要`onKey`在 a 上设置回调，`FocusNode`或者`FocusScopeNode`它们是否由 a`Focus`或`FocusScope`小部件管理。如果您想要一个处理程序，请在您想要收听的小部件子树周围`onKey`添加一个新小部件，并将小部件的属性设置为您的处理程序。如果您也不希望它成为主要焦点，请在小部件上设置。这是因为小部件上的属性可以在后续构建中设置为其他内容，如果发生这种情况，它会覆盖您在节点上设置的处理程序。`Focus``onKey``canRequestFocus: false``onKey``Focus``onKey`
    
*   一定要调用`requestFocus()`一个节点来请求它接收主要焦点，尤其是来自一个祖先，该祖先已经将它拥有的节点传递给你想要关注的后代。
    
*   使用`focusNode.requestFocus()`. 没有必要打电话`FocusScope.of(context).requestFocus(focusNode)`。该`focusNode.requestFocus()`方法等效且性能更高。