> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/1951161369)

> 上一篇讲的是单表查询的优化，（本文末有链接）。当然，对数据表的多表查询也是必不可少的。本篇内容主要讲解多表联合查询的优化一、多表查询连接的选择：相信这内连接，左连接什么的大家都

> 上一篇讲的是单表查询的优化，（本文末有链接）。当然，对数据表的多表查询也是必不可少的。本篇内容主要讲解多表联合查询的优化

![](http://image.skjava.com/article/series/mysql/202303282258209001.png)

相信这内连接，左连接什么的大家都比较熟悉了，当然还有左外连接什么的，基本用不上我就不贴出来了。这图只是让大家回忆一下，各种连接查询。 然后要告诉大家的是，需要根据查询的情况，想好使用哪种连接方式效率更高。

在 MySQL 中，只有一种 Join 算法，就是大名鼎鼎的 Nested Loop Join，他没有其他很多数据库所提供的 Hash Join，也没有 Sort Merge Join。顾名思义，Nested Loop Join 实际上就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与 Join，则再通过前两个表的 Join 结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。 ——摘自《MySQL 性能调优与架构设计》

三、补充：mysql 对 sql 语句的容错问题

即在 sql 语句不完全符合书写建议的情况，mysql 会允许这种情况，尽可能解释它：

1) 一般 cross join 后面加上 where 条件，但是用 cross join+on 也是被解释为 cross join+where；

2) 一般内连接都需要加上 on 限定条件，如上面场景一；如果不加会被解释为交叉连接；

3) 如果连接表格使用的是逗号，会被解释为交叉连接；

注：sql 标准中还有 union join 和 natural inner join，mysql 不支持，而且本身也没有多大意义，其实就是为了 “健壮”。但是其实结果可以用上面的几种连接方式得到。

当然，关于这句话，也不一定就全是这样。

1）因为在大型的数据处理中，子查询是非常常见的，特别是在查询出来的数据需要进一步处理的情况，无论是可读性还是效率上，这时候的子查都是更优。

2）然而在一些特定的场景，可以直接从数据库读取就可以的，比如一个表（A 表 a，b，c 字段，需要内部数据交集）join 自己的效率必然比放一个子查在 where 中快得多。

UNION 是会把结果排序的！！！

union 查询：它可以把需要使用临时表的两条或更多的 select 查询合并的一个查询中（即把两次或多次查询结果合并起来。）。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select 语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。

要求：两次查询的列数必须一致（列的类型可以不一样，但推荐查询的每一列，相对应的类型要一样）

可以来自多张表的数据：多次 sql 语句取出的列名可以不一致，此时以第一个 sql 语句的列名为准。

如果不同的语句中取出的行，有完全相同 (这里表示的是每个列的值都相同)，那么 union 会将相同的行合并，最终只保留一行。也可以这样理解，union 会去掉重复的行。

如果不想去掉重复的行，可以使用 union all。

如果子句中有 order by,limit，需用括号 () 包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选。

![](http://image.skjava.com/article/series/mysql/202303282258219422.png)

注意：

1、UNION 结果集中的列名总是等于第一个 SELECT 语句中的列名

2、UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同

UNION ALL 的作用和语法：

默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。

![](http://image.skjava.com/article/series/mysql/202303282258236053.png)

（1）对于要求全面的结果时，我们需要使用连接操作（LEFT JOIN / RIGHT JOIN / FULL JOIN）；

（2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

![](http://image.skjava.com/article/series/mysql/202303282258251714.png)

备注、描述、评论之类的可以设置为 NULL，其他最好不要使用 NULL。

不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段， null 不占用空间。

可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：

select id from t where num = 0

（3）in 和 not in 也要慎用，否则会导致全表扫描，如：

![](http://image.skjava.com/article/series/mysql/202303282258265275.png)

对于连续的数值，能用 between 就不要用 in 了：

![](http://image.skjava.com/article/series/mysql/202303282258278736.png)

很多时候用 exists 代替 in 是一个好的选择：

![](http://image.skjava.com/article/series/mysql/202303282258290837.png)

（4）尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

（5）尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

（6）不要以为使用 MySQL 的一些连接操作对查询有多么大的改善，其实核心是索引（别打我，下一篇讲）

「mysql 优化专题」这大概是一篇最好的 mysql 优化入门文章（1）

「mysql 优化专题」90% 程序员都会忽略的增删改优化（2）

「mysql 优化专题」单表查询优化的一些小总结（3）

> 今天多表查询优化就讲到这里，觉得有收获的同学可以收藏关注。本号内有多个专题，如【数据结构】、【netty 专题】、【dubbo 专题】、【mysql 优化专题】、【redis 专题】、【高并发专题】等, 将会陆续添加, 设置成关键字.