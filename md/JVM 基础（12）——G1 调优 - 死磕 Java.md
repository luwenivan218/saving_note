> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/8226599505)

> 一、简介本章和下一章，我们将通过一个实际案例来讲解如何针对 G1 进行 JVM 参数调优。G1 的优化思想和 “ParNew+CMS” 是类似的，我们将通过案例，按照 G1 的垃圾回收过程，逐步

一、简介
----

本章和下一章，我们将通过一个实际案例来讲解如何针对 G1 进行 JVM 参数调优。G1 的优化思想和 “ParNew+CMS” 是类似的，我们将通过案例，按照 G1 的垃圾回收过程，逐步优化。

还是先来看下案例的背景，把整个系统的核心业务流程、峰值流量、内存使用模型梳理清楚。

### 1.1 案例背景

假设现在有一个在线教育平台，日活用户几十万，其核心业务流程就是：用户浏览 -> 选择课程 -> 下单付费 -> 选课排课。这样一个流程，几乎没什么并发度，这种在线教育系统，高峰期一般在晚上的 2~3 个小时内，占据全天流量的 99%，此时几十万用户会在这集中的 2-3 个小时内进行在线学习。

![](http://image.skjava.com/article/series/jvm/202308102128386091.png)

### 1.2 内存使用模型估算

交代完了背景，我们再来估算下高峰时期的系统内存使用模型：

我们假设有 60 万用户会在晚间 3 个小时内集中访问系统，那么就是每小时 20 万用户。这 20 万用户每人每分钟会在平台上进行 1 次互动操作，那么 20 万用户 1 小时内总共进行 1200 万次互动操作，平均每秒大概 3000 次互动操作。

也就是说，我们的在线教育系统需要 **能够承载每秒 3000 次并发请求** 。根据经验，4 核 8G 的机器抗个每秒 600 并发请求没有问题，所以我们一 **共部署 5 台 4 核 8G 的机器** 。

我们假设一次请求产生的对象大小为 5KB，那一秒钟 600 次请求总共产生 3MB 对象，一分钟就是 18MB 对象。

二、G1 调优
-------

### 2.1 初始状态

我们先来看下 G1 的初始内存布局，采用 4 核 8G 的机器，给 Java 堆空间分配 4G 内存，其中新生代初始占比 5%（200MB），最大 60%，每个 Java 线程的栈内存占 1MB，元数据区（永久代）的内存为 256MB，如下图：

![](http://image.skjava.com/article/series/jvm/202308102128391712.png)

预期停顿时间，我们采用默认值 200ms，即希望每次触发 GC 时，系统停顿时间不超过 200ms，可以通过参数`-XX:MaxGCPauseMills`设置。

此时，JVM 的参数配置如下：

`-Xms:4096M -Xmx:4096M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:UseG1GC -XX:G1NewSizePercent=5 -XX:G1MaxNewSizePercent=60 -XXMaxGCPauseMills=200`

> -XX:G1NewSizePercent 用来设置新生代的初始占比， -XX:G1MaxNewSizePercent 用来设置新生代的最大占比。初始状态下，每个 Resion 为 2MB，新生代一共 100 个 Region。

### 2.2 新生代对象分配

系统运行后，会不断的在新生代的 Eden 区分配对象，按照之前的计算，每秒分配 3MB 对象，那么 1 分钟左右就会将塞满 100 个 Region，大约 200MB：

![](http://image.skjava.com/article/series/jvm/202308102128396423.png)

新生代的大小是在 5%~60% 之间动态变化的，那是否直到新生代占据了 60% 的 Region 后，才会触发新生代的 GC？

显然不是的，G1 的新生代 GC 触发机制如下：随着新生代 Region 的不断分配， **G1 会动态监测每个 Region 的回收价值，当它发现新生代的某些 Region 的总回收时间差不多接近预期停顿时间时，就会触发一次新生代 GC** 。

举个例子，假设上述的在线教育系统，G1 回收掉 300 个 Region 需要 200ms，接近 “预期停顿时间”。那么当最初的 100 个 Region 占满后，G1 会判断，如果此时进行回收仅需要几十 ms，远小于 200ms，新生代频繁 GC 是不好的，还不如再等会儿，于是会给新生代再增加些 Region，然后继续在里面分配对象：

![](http://image.skjava.com/article/series/jvm/202308102128402984.png)

然后系统继续运行，直到 300Region 都快占满了，此时 GC 评估下总体回收时间，接近 200ms，那么这个时候就可能触发一次新生代的 GC，从而保证了 GC 时间在 “预期停顿时间” 范围内。

> 事实上，G1 到底会分配多少 Region 给新生代，多久触发一次新生代 GC，每次 GC 耗费多长时间，这些都是不确定的，必须通过一些工具去查看系统实际运行情况才能知道，这块我们后续实战篇中会进行讲解。

### 2.3 新生代 GC 优化

G1 是非常适合大内存的机器的，所以应该给 JVM 分配足够的 Java 堆内存，然后设置合理的预期停顿时间。

`-XX:MaxGCPauseMills`这个参数设置太小，就会导致 G1 对新生代进行频繁 GC，虽然每次 GC 的停顿时间很短。如果这个参数设置太大，那么 G1 会等到积累了很多对象后一次性回收，此时一次新生代 GC 的停顿时间可能达到几百毫秒，但是 GC 的频率很低。

所以，`-XX:MaxGCPauseMills`参数的设置，需要结合系统压测工具、GC 日志、内存分析工具综合考虑，既然保证系统的 GC 频率不会太高，也要保证每次 GC 的停顿时间不会太长。后续实战篇，我们会详解具体分析的方法。

### 2.4 Mixed GC 优化

当老年代的 Region 数量达到堆内存的 45% 时（通过参数`-XX:InitiatingHeapOccupancyPercent`可以配置），会触发一次 **混合回收（Mixed GC）** ，即对新生代和老年代一起回收。

我们之前已经讲解过了 G1 中对象进入老年代的几个条件：

*   对象躲过了多次 GC，达到一定的年龄（`-XX:MaxTenuringThrehold`参数设置）；
*   符合动态年龄判断规则，即某次新生代 GC 后，各年龄存活对象的累加大小超过了 Survivor 的 50%；

所以，对于 Mixed GC 的优化，核心思路还是尽量减少对象进入老年代。优化方式主要还是调整`-XX:MaxGCPauseMills`这个参数，在保证新生代 GC 别太频繁的同时，还要考虑每次 GC 过后存活对象的大小，避免存活对象太多太快进入老年代，频繁触发 Mixed GC。

> 到底如何优化`-XX:MaxGCPauseMills`这个参数，涉及大量工具，我们在后续的实战篇系列中再详细分析。

三、总结
----

截止本章为止，我们已经深入讲解了 JVM 的内存模型、垃圾回收机制，以及 “ParNew+CMS” 和 G1 垃圾回收器的原理，并结合案例讲解了 JVM 的基本调优思路和步骤。

下一章开始，我们将进入[实战系列](https://www.tpvlog.com/article/84)，通过各种实际案例，讲解如何真正进行线上环境的 JVM 调优，包括各类工具的使用以及如何通过 JVM 日志分析问题。