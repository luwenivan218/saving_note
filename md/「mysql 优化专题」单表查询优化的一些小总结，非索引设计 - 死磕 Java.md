> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/2449853722)

> 上篇讲解了「mysql 优化专题」90% 程序员都会忽略的增删改优化（2），相信大家都有所收获。接下来这篇是查询优化。其实，大家都知道，查询部分是远远大于增删改的，所以查询优化会花

转

 2023-03-28  阅读 (193)  点赞 (0)

原文地址：https://cloud.tencent.com/developer/article/1185462

> 上篇讲解了「mysql 优化专题」90% 程序员都会忽略的增删改优化（2），相信大家都有所收获。接下来这篇是查询优化。其实，大家都知道，查询部分是远远大于增删改的，所以查询优化会花更多篇幅去讲解。本篇会先讲单表查询优化（非索引设计）。然后讲多表查询优化。索引优化设计以及库表结构优化等后面文章再讲。

![](http://image.skjava.com/article/series/mysql/202303282258155741.png)

（0）可以先使用 EXPLAIN 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮我们分析是查询语句或是表结构的性能瓶颈。

（1）写 sql 要明确需要的字段，要多少就写多少字段，而不是滥用 select *

（2）可以用使用连接（JOIN）来代替子查询

（3）使用分页语句：limit start , count 或者条件 where 子句时，有什么可限制的条件尽量加上，查一条就 limit 一条。做到不滥用。比如说我之前做过的的 p2p 项目, 只是需要知道有没有一个满标的借款，这样的话就可以用上 limit 1，这样 mysql 在找到一条数据后就停止搜索，而不是全文搜索完再停止。

（4）开启查询缓存：

大多数的 MySQL 服务器都开启了查询缓存。这是提高查询有效的方法之一。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。

查询缓存工作流程：

A)：服务器接收 SQL，以 SQL+DB+Query_cache_query_flags 作为 hash 查找键；

B)：找到了相关的结果集就将其返回给客户端；

C)：如果没有找到缓存则执行权限验证、SQL 解析、SQL 优化等一些列的操作；

D)：执行完 SQL 之后，将结果集保存到缓存

当然，并不是每种情况都适合使用缓存，衡量打开缓存是否对系统有性能提升是一个整体的概念。那怎么判断要不要开启缓存呢，如下：

1）通过缓存命中率判断, 缓存命中率 = 缓存命中次数 (Qcache_hits) / 查询次数 (Com_select)、

2）通过缓存写入率, 写入率 = 缓存写入次数 (Qcache_inserts) / 查询次数 (Qcache_inserts)

3）通过 命中 - 写入率 判断, 比率 = 命中次数 (Qcache_hits) / 写入次数 (Qcache_inserts), 高性能 MySQL 中称之为比较能反映性能提升的指数, 一般来说达到 3:1 则算是查询缓存有效, 而最好能够达到 10:1

相关参数及命令：

与缓存相关的主要参数如下表所示。可以使用命令 SHOW VARIABLES LIKE '%query_cache%'查看

![](http://image.skjava.com/article/series/mysql/202303282258169772.png)

缓存数据失效时机

在表的结构或数据发生改变时，查询缓存中的数据不再有效。有这些 INSERT、UPDATE、 DELETE、TRUNCATE、ALTER TABLE、DROP TABLE 或 DROP DATABASE 会导致缓存数据失效。所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用。

可以使用下面三个 SQL 来清理查询缓存：

1、FLUSH QUERY CACHE; // 清理查询缓存内存碎片。

2、RESET QUERY CACHE; // 从查询缓存中移出所有查询。

3、FLUSH TABLES; // 关闭所有打开的表，同时该操作将会清空查询缓存中的内容。

InnoDB 与查询缓存：

Innodb 会对每个表设置一个事务计数器, 里面存储当前最大的事务 ID. 当一个事务提交时, InnoDB 会使用 MVCC 中系统事务 ID 最大的事务 ID 跟新当前表的计数器.

只有比这个最大 ID 大的事务能使用查询缓存, 其他比这个 ID 小的事务则不能使用查询缓存.

另外, 在 InnoDB 中, 所有有加锁操作的事务都不使用任何查询缓存

> 本篇基于单表查询的查询优化（非索引设计）就说到这里，喜欢的朋友可以收藏关注一波。本头条号内有多个专题，如【数据结构】、【netty 专题】、【dubbo 专题】、【mysql 优化专题】、【redis 专题】、【高并发专题】等优质好文。一起学习，共同进步。