> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.skjava.com](https://www.skjava.com/series/article/1943960326)

> 一、简介本章将会讲解一个频繁 FullGC 的案例，示例来自于 JVM 基础篇中的亿量级计算系统。我们先来回顾下案例。1.1 案例背景假设现在生产环境有一套 “数据计算系统”，不停地从 My

一、简介
----

本章将会讲解一个频繁 Full GC 的案例，示例来自于 JVM 基础篇中的[亿量级计算系统](https://www.tpvlog.com/article/89)。我们先来回顾下案例。

### 1.1 案例背景

假设现在生产环境有一套 “数据计算系统”，不停地从 MySQL 等各类数据源提取数据到内存中进行计算，系统是分布式的。

每个节点（机器）每分钟执行 100 次操作（提取数据并计算，每次操作耗时 10s），每次操作 1 万条数据，每条数据大小为 1KB 左右，每次操作的数据大小就是 10MB：

![](http://image.skjava.com/article/series/jvm/202308102131381731.png)

> 每台机器的配置是 4 核 8G，JVM 分配 4G 内存，其中新生代 1.5G，老年代 1.5G。

### 1.2 内存使用模型估算

每次操作会在 Eden 区分配 10MB 对象，以 1 分钟 100 次操作来算，那么 Eden 区 1 分钟内就会被占满：

![](http://image.skjava.com/article/series/jvm/202308102131386592.png)

二、Full GC 调优
------------

每个计算任务处理 1 万条数据耗时 10s，假设此时 80 个计算任务都结束了，还有 20 个计算任务共计 200MB 正在计算中，那么此时 200MB 对象是存活的，不会被 Young GC 回收掉：

![](http://image.skjava.com/article/series/jvm/202308102131395473.png)

### 2.1 扩 Survivor

由于任何一块 Survivor 区只有 100MB，所以新生代中这存活的 200MB 对象会晋升到老年代，然后清空 Eden：

![](http://image.skjava.com/article/series/jvm/202308102131402084.png)

如此反复，大约经过 7 分钟后，也就是经历了 7 次 Young GC，此时大概有 1.4G 对象在老年代中：

![](http://image.skjava.com/article/series/jvm/202308102131406725.png)

再经过 1 分钟，也就是第 8 分钟结束时，新生代又满了，此时发现老年代可用空间已经不足（剩余 100MB），比历代平均的晋升对象大小（200MB）要小，所以会直接触发一次 Full GC。

Full GC 会先把老年代的垃圾回收了（假设能全部回收），然后执行一次 Young GC，此时 Eden 区存活的对象会进入老年代：

![](http://image.skjava.com/article/series/jvm/202308102131414956.png)

按照这种情况，每隔 8 分钟左右就会发生一次 Full GC。Full GC 的性能是很差的，所以必须进行优化，最基本的优化思路就是扩大 Survivor 区的内存，比如扩到 200MB。这样基本就能避免对象频繁进入老年代，将 Full GC 频率降低到几个小时一次。

### 2.2 采用大内存

上述的示例，是假设系统每天的负载是 1 亿请求， **如果请求量再扩大十倍呢？**

参照首节的内存使用模型来估算， **每秒中会有 100MB 左右的数据进入 Eden，那么 Eden 会在 10s 内就被塞满，触发 Young GC** 。

计算任务本身就耗时 10s 左右，所以直接后果就是，即使进行了 Young GC，可能也只能回收掉几百 MB 数据。那每隔 10s，就有 1G 左右的数据进入老年代，那下一个 10s 又来 1G 数据，就会触发 Full GC。最终的结果就是每分钟触发好几次 Full GC，对于系统来说就是灾难。

所以，针对这个问题，首先要做的显然就是扩内存，比如换成 16 核 32G 的机器，Eden 分配 16G，Survivor 各分配 2G。那么按每秒加载 100MB 数据进内存来算，需要 2 分钟左右才会触发一次 YoungGC，而每次 Young GC 的存活对象也就是几百 MB，Survivor 区足够容纳。这就避免了对象频繁进入老年代，触发 Full GC。

_那么，针对这种大内存的机器，我们是否需要用 G1 作为垃圾回收器呢？_

对于本示例中的系统是不需要的，因为这种数据计算系统一般都是离线的，也就是说不和用户直接交互，所以哪怕每隔 2 分钟进行一次 Young GC，每次 Young GC 耗时 1s 也没什么影响。